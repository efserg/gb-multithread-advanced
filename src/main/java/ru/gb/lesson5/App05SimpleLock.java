package ru.gb.lesson5;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class App05SimpleLock {
    // Интерфейс Lock из пакета java.util.concurrent – это продвинутый механизм синхронизации
    // потоков. По гибкости он выигрывает в сравнении с блоками синхронизации. Для работы с этим
    // интерфейсом необходимо создать объект одной из его реализаций
    public static void main(String[] args) {
        final Lock lock = new ReentrantLock();
        new Thread(() -> {
            lock.lock();
            try {
                // Критическая секция
            } finally {
                lock.unlock();
            }
        }).start();

        // lock() - блокирует объект типа Lock, если это возможно. Если объект уже был
        //          заблокирован, то поток, вызвавший метод lock(), блокируется до вызова unlock().
        // tryLock() - пытается заблокировать объект типа Lock, если это возможно. При удачном
        //          блокировании вернет «true». Если же Lock уже был заблокирован – то «false»,
        //          и поток, вызвавший tryLock(), не будет заблокирован.
        // tryLock(long timeout, TimeUnit timeUnit) - Похож на tryLock(), но в течение заданного
        //          времени пытается захватить объект Lock.
        // unlock() - разблокирует объект Lock. Вызывается только потоком, который владеет
        //          блокировкой Lock. При попытке других потоков обратиться к этому методу будет
        //          выдано исключение RuntimeException.

        // В отличии от синхронизированных блоков, которые должны полностью содержаться в одном
        // методе, Lock может быть захвачен в одном методе, а освобожден в другом.

    }


}
